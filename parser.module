<?php

/**
 * Implements hook_menu()
 */
function parser_menu() {
  $items['parser/check'] = array(
    'page callback' => 'parser_check_code',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );
  
  $items['admin/structure/parser_jobs/results/%parser_job'] = array(
    'title' => 'Parser results',
    'page callback' => 'parser_result_page',
    'page arguments' => array(4),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );
  
  return $items;
}

/**
 * Implements hook_entity_info()
 */
function parser_entity_info() {
  return array(
    'parser_job' => array(
      'label' => t('Job parsing'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIController',
      'base table' => 'parser_jobs',
      'entity keys' => array(
        'id' => 'jid',
        'label' => 'title'
      ),
      'admin ui' => array(
        'path' => 'admin/structure/parser_jobs'
      ),
      'uri callback' => 'parser_job_uri',
      'access callback' => 'parser_job_access',
      'module' => 'parser',
      'exportable' => TRUE,
    ),
  );
}

/**
 * Check acces rights
 */
function parser_job_access($op, $entity, $account = NULL, $entity_type = 'parser_job') {
  return user_access('administer site configuration');
}
 
/**
 * Load entity object by id
 */
function parser_job_load($id) {
  $result = entity_load('parser_job', array($id));
  return $result ? reset($result) : FALSE;
}

/**
 * Parser job uri callback
 */
function parser_job_uri($job) {
  return array(
    'path' => 'admin/structure/parser_jobs/manage/' . $job->jid,
  );
}

/**
 * Menu callback
 */
function parser_job_form($form, &$form_state, $job) {
  $check_button = array('#field_prefix' => '<input type="button" value="проверить" class="form-submit check-button" />');
  $fields_code = isset($job->fields_code) ? $job->fields_code : array();
  $entity_types = entity_get_info();
  $fields_info = field_info_fields(); dsm($fields_info);
  $formats = filter_formats();
  $weight = 0;
  
  $entity_type_options = array();
  foreach ($entity_types as $entity_type => $entity_info) {
    $entity_type_options[$entity_type] = $entity_info['label'];
  }
  
  $entity_type_value = isset($job->entity_type) ? $job->entity_type : 'node';
  if (isset($form_state['values']['entity_type'])) {
    $entity_type_value = $form_state['values']['entity_type'];
  }
  
  $bundle_options = array();
  foreach ($entity_types[$entity_type_value]['bundles'] as $bundle_name => $bundle_info) {
    $bundle_options[$bundle_name] = $bundle_info['label'];
  }
  
  $bundle_value = isset($job->bundle) ? $job->bundle : key($bundle_options);
  if (isset($form_state['values']['bundle']) && isset($bundle_options[$form_state['values']['bundle']])) {
    $bundle_value = $form_state['values']['bundle'];
  }
  
  $entity_keys = $entity_types[$entity_type_value]['entity keys'];
  $bundle_key = $entity_keys['bundle'];
  $label_key = isset($entity_keys['label']) ? $entity_keys['label'] : '';
  
  $entity_properties = entity_get_property_info($entity_type_value);
  if ($entity_type_value == 'taxonomy_term') {
    unset($entity_properties['properties']['vocabulary']);
  }
  if (isset($entity_properties['properties'][$bundle_key])) {
    unset($entity_properties['properties'][$bundle_key]);
  }
  dsm($entity_properties);
  
  $fields_instances = field_info_instances($entity_type_value, $bundle_value);
  
  $format_options = array();
  foreach ($formats as $format) {
    $format_options[$format->format] = $format->name;
  }
  
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => 'Название задания',
    '#description' => 'Будет отображаться в списке с заданиями. Пример заполнения: <code>Парсинг проектов на drupal.org</code>',
    '#required' => TRUE,
    '#default_value' => isset($job->title) ? $job->title : '',
    '#maxlength' => 255,
  );
  
  $form['start_url'] = array(
    '#type' => 'textfield',
    '#title' => 'Стартовый URL',
    '#description' => 'Адрес, с которого парсер начнёт работу. Пример заполнения: <code>http://drupal.org/project/modules</code>',
    '#required' => TRUE,
    '#default_value' => isset($job->start_url) ? $job->start_url : '',
    '#maxlength' => 255,
  );
  
  $form['test_url'] = array(
    '#type' => 'textfield',
    '#title' => 'URL тестовой страницы',
    '#description' => 'Адрес любой страницы, попадающей под условие парсинга, которая будет использоваться для проверки работоспособности кода.',
    '#required' => TRUE,
    '#default_value' => isset($job->test_url) ? $job->test_url : '',
    '#maxlength' => 255,
  );
  
  $form['depth'] = array(
    '#type' => 'textfield',
    '#title' => 'Глубина',
    '#description' => 'Глубина, на которую парсер будет ходить по ссылкам. Например 1 означает, что будет распарсен стартовый адрес и страницы на которые он ссылается, т.е. парсер пройдёт вглубь на 1 уровень относительно стартовой страницы.',
    '#required' => TRUE,
    '#default_value' => isset($job->depth) ? $job->depth : '',
    '#size' => 5,
  );
  
  $form['white_list'] = array(
    '#type' => 'textarea',
    '#title' => 'Белый список адресов',
    '#description' => 'Маски адресов, по которым будет разрешено ходить парсеру. Каждая маска на новой строке. Оставьте пустым, если парсеру разрешено ходить по всем найденным ссылкам. Пример заполнения: <code>http://drupal.org/project/*</code>',
    '#default_value' => isset($job->white_list) ? $job->white_list : '',
    '#rows' => 3,
  );

  $form['black_list'] = array(
    '#type' => 'textarea',
    '#title' => 'Чёрный список адресов',
    '#description' => 'Маски адресов, по которым будет запрещено ходить парсеру. Каждая маска на новой строке. Пример заполнения: <code>http://drupal.org/project/uc_*</code>',
    '#default_value' => isset($job->black_list) ? $job->black_list : '',
    '#rows' => 3,
  );
  
  $form['check_code'] = array(
    '#type' => 'textarea',
    '#title' => 'Код проверки для дальнейшего парсинга страницы',
    '#description' => '
      PHP код без тегов &lt;?php и ?&gt;, который должен вернуть TRUE если страницу нужно парсить в ноду. Доступные переменные: $page - html код страницы, $doc - объект phpQuery, $page_url -
      адрес страницы без учёта редиректов. Пример заполнения: <code>return ($doc->find(\'.class-name\')->length() > 0);</code><br />Если возвращаемое значение будет числом или строкой, то оно
      будет расценено как идентификатор страницы (аналог nid). Этот идентификатор будет сохранён в бд и позволит избежать дублей материалов, которые доступны по нескольким URL.
    ',
    '#default_value' => isset($job->check_code) ? $job->check_code : '',
    '#rows' => 3,
    '#resizable' => FALSE,
  ) + $check_button;
  
  // Entity type
  $form['entity_type'] = array(
    '#type' => 'select',
    '#title' => 'Сущность',
    '#description' => 'Выберите тип сущности, которую будет создавать парсер.',
    '#options' => $entity_type_options,
    '#default_value' => isset($job->entity_type) ? $job->entity_type : 'node',
    '#required' => TRUE,
    '#ajax' => array('callback' => 'parser_job_form_entity_type_ajax_callback'),
    '#disabled' => isset($job->jid) && db_select('parser_map')->condition('jid', $job->jid)->countQuery()->execute()->fetchField() ? TRUE : FALSE,
  );
  
  // Bundle
  $form['bundle'] = array(
    '#type' => 'select',
    '#title' => 'Тип (bundle)',
    '#description' => 'Выберите тип сущности, который будет создавать парсер.',
    '#options' => $bundle_options,
    '#default_value' => isset($job->bundle) ? $job->bundle : key($bundle_options),
    '#required' => TRUE,
    '#prefix' => '<div id="edit-bundle-wrapper">',
    '#suffix' => '</div>',
    '#ajax' => array(
      'callback' => 'parser_job_form_fields_ajax_callback',
      'wrapper' => 'fields-code-wrapper',
    ),
  );
  
  $form['fields_wrapper'] = array(
    '#prefix' => '<div id="fields-code-wrapper">',
    '#suffix' => '</div>',
  );
  
  $form['fields_wrapper']['fields_code'] = array(
    '#type' => 'fieldset',
    '#title' => 'Поля',
    '#description' => '
      <p>Поля заполняются без обёртки кода в &lt;?php и ?&gt;. Во всех полях доступны три переменные $doc - объект phpQuery, $page - html код страницы, $page_url - адрес страницы без учёта
      редиректов. Оставьте textarea пустым, если поле заполнять не нужно.<p><p>Если появляются проблемы с кодировкой, то попробуйте сменить значение в поле <i>Кодировка сайта</i>, либо включите
      опцию <i>Передовать кодировку в конструктор phpQuery</i>, либо используйте функцию <a href="http://www.php.net/manual/ru/function.iconv.php" target="_blank">iconv()</a>, для ручной
      конвертации текста. Например: <code style="font-size:.9em;">return iconv(\'WINDOWS-1251\', \'UTF-8\', $doc->find(\'selector\')->text());</code></p>
    ',
    '#tree' => TRUE,
  );
  
  // Fields
  foreach (($entity_properties['properties'] + $entity_properties['bundles'][$bundle_value]['properties']) as $field_name => $field_info) {
    if (!empty($field_info['computed'])) {
      continue;
    }
    
    $field_type = isset($field_info['type']) ? $field_info['type'] : '';
    
    $form['fields_wrapper']['fields_code'][$field_name . '_fieldset'] = array(
      '#type' => 'fieldset',
      '#title' => $field_info['label'] . ' (' . $field_name . ')' . (!empty($field_info['required']) ? ' *' : ''),
      '#description' => isset($field_info['description']) ? $field_info['description'] : '',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => (!empty($field_info['required']) || !empty($field_info['field'])) ? $weight : $weight + 100,
    );
    
    $form['fields_wrapper']['fields_code'][$field_name . '_fieldset'][$field_name] = array(
      '#type' => 'textarea',
      '#title' => 'PHP код',
      '#description' => 'PHP код, который должен вернуть значение поля' . ($field_type ? ' (тип значения: ' . $field_type . ')' : ''),
      '#default_value' => isset($fields_code[$field_name]) ? $fields_code[$field_name] : '',
      '#rows' => 3,
      '#resizable' => FALSE,
      '#required' => !empty($field_info['required']),
    ) + $check_button;
    
    $weight++;
  }
  
  $form['advanced_settings'] = array(
    '#type' => 'fieldset',
    '#title' => 'Дополнительные настройки',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  
  $form['advanced_settings']['parse_limit'] = array(
    '#type' => 'textfield',
    '#title' => 'Ограничить число создаваемых/обновляемых сущностей',
    '#description' => 'Максимальное число сущностей, которое сможет создать/обновить парсер. Применяется в осномном при тестировании задания. Оставьте пустым, если ограничения не нужны.',
    '#default_value' => !empty($job->parse_limit) ? $job->parse_limit : '',
    '#size' => 5,
  );
  
  $form['advanced_settings']['site_charset'] = array(
    '#type' => 'select',
    '#title' => 'Кодировка сайта',
    '#description' => 'Выберите кодировку, которая используется на сайте. Рекомендуется автоопределение.',
    '#options' => array('auto' => 'Автоопределение', 'UTF-8' => 'UTF-8', 'WINDOWS-1251' => 'WINDOWS-1251'),
    '#default_value' => isset($job->site_charset) ? $job->site_charset : 'auto',
  );
  
  $form['advanced_settings']['charset_fix'] = array(
    '#type' => 'checkbox',
    '#title' => 'Передавать кодировку в конструктор phpQuery',
    '#description' => 'Отметьте эту опцию, если возникают проблемы с кодировкой. Костыль для phpQuery.',
    '#default_value' => isset($job->charset_fix) ? $job->charset_fix : FALSE,
  );
  
  $form['advanced_settings']['only_this_domen'] = array(
    '#type' => 'checkbox',
    '#title' => 'Парсить только с этого же домена',
    '#description' => 'Отметьте, если хотите чтобы парсер работал только на домене, указанном в поле "Стартовый URL".',
    '#default_value' => isset($job->only_this_domen) ? $job->only_this_domen : TRUE,
  );
  
  $form['advanced_settings']['save_url'] = array(
    '#type' => 'checkbox',
    '#title' => 'Сохранять адреса',
    '#description' => 'Отметьте, если хотите, чтобы у нод были такие же адреса, как на оригинальном сайте. Не включайте эту опцию если на оригинальном сайте не используется ЧПУ (т.е. в адресах есть символ "?")',
    '#default_value' => isset($job->save_url) && module_exists('path') ? $job->save_url : 0,
    '#disabled' => !module_exists('path'),
  );
  
  $form['advanced_settings']['no_update'] = array(
    '#type' => 'checkbox',
    '#title' => 'Не обновлять сущности',
    '#description' => 'Отметьте, если не хотите обновлять ноды, созданные в предыдущие запуски этого задания',
    '#default_value' => isset($job->no_update) ? $job->no_update : 0,
  );
  
  $form['advanced_settings']['prepare_code'] = array(
    '#type' => 'textarea',
    '#title' => 'Пост-обработка сущности',
    '#description' => 'Код, который будет выполнен перед вызовом entity_save(). Доступные переменные: $entity - объект сущности, $page - html код страницы, $doc - объект phpQuery. Пример заполнения: <code>$entity->title = \'new title\';</code>',
    '#default_value' => isset($job->prepare_code) ? $job->prepare_code : '',
    '#rows' => 3,
    '#resizable' => FALSE,
  );
  
  $form['actions'] = array(
    '#type' => 'actions',
  );
  
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Сохранить задание',
  );
  
  $form['actions']['submit_and_start'] = array(
    '#type' => 'submit',
    '#value' => 'Сохранить задание и Начать парсинг',
  );
  
  _parser_set_rows($form);
  
  $parser_path = drupal_get_path('module', 'parser');
  $form['#attached']['library'][] = array('system', 'ui.dialog');
  $form['#attached']['library'][] = array('parser', 'codemirror');
  $form['#attached']['css'][] = $parser_path . '/parser.css';
  $form['#attached']['js'][] = $parser_path . '/parser.js';

  return $form;
}

/**
 * Ajax callback
 */
function parser_job_form_entity_type_ajax_callback($form, $form_state) {
  $commands[] = ajax_command_insert('#edit-bundle-wrapper', drupal_render($form['bundle']));
  $commands[] = ajax_command_insert('#fields-code-wrapper', drupal_render($form['fields_wrapper']));
  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Ajax callback
 */
function parser_job_form_fields_ajax_callback($form, $form_state) {
  return $form['fields_wrapper'];
}

/**
 * Job form submit callback
 */
function parser_job_form_submit(&$form, &$form_state) {
  $clicked_button = $form_state['clicked_button']['#value'];
  $fields = field_info_fields();
  $fields_code = array();
  
  if (isset($form_state['values']['fields_code'])) {
    foreach ($form_state['values']['fields_code'] as $fieldset) {
      foreach ($fieldset as $field_name => $field_code) {
        $fields_code[$field_name] = $field_code;
      }
    }
    $fields_code = array_diff($fields_code, array(''));
  }
  $form_state['values']['fields_code'] = $fields_code;
  
  if (!$form_state['values']['parse_limit']) {
    $form_state['values']['parse_limit'] = 0;
  }
  
  $job = entity_ui_form_submit_build_entity($form, $form_state);
  $job->save();
  
  if ($form_state['clicked_button']['#value'] == $form_state['values']['submit']) {
    drupal_set_message('Задание сохранено.');
    $form_state['redirect'] = 'admin/structure/parser_jobs/manage/' . $job->jid;
  }
  else {
    // Clear vocabularies
    foreach ($fields as $field_name => $field) {
      if (
        isset($field['bundles'][$job->entity_type]) &&
        in_array($job->bundle, $field['bundles'][$job->entity_type]) &&
        $field['type'] == 'taxonomy_term_reference' &&
        $fields_code[$field_name . '_clear_voc']
      ) {
        _parser_clear_vocabulary($field['settings']['allowed_values'][0]['vocabulary']);
      }
    }
    
    _parser_url_delete_all();
    _parser_url_add($job->start_url);
  
    $batch = array(
      'title' => 'Парсинг',
      'progress_message' => '',
      'operations' => array(
        array('parser_parse', array($job)),
      ),
      'finished' => 'parser_finished',
    );

    batch_set($batch);
  }
}

/**
 * Parse page
 */
function parser_parse($job, &$context) {
  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['entity_ids'] = array();
    $context['sandbox']['created_entities'] = 0;
    $context['results']['jid'] = $job->jid;
    $context['results']['time_start'] = time();
    $context['results']['created_entities'] = 0;
    $context['results']['updated_entities'] = 0;
    $context['results']['pages_from_http'] = 0;
    $context['results']['error_pages_from_http'] = 0;
    $context['results']['pages_from_cache'] = 0;
    $context['results']['downloaded_files'] = 0;
    $context['results']['files_from_cache'] = 0;
  }
  
  $url = _parser_url_get_not_parsed();
  $page_url = $url->url;
  $parsed_url = parse_url($page_url);
  $page = _parser_get_page_by_url($page_url, $job->site_charset, FALSE, $context['results']);
  $doc = _parser_create_phpquery($page, $job->charset_fix);
  $entity_id = parser_get_entity_id_by_url($page_url, $job->jid);
  $entity_type_info = entity_get_info($job->entity_type);
  $page_key = '';
  
  if ($url->depth < $job->depth) {
    // Find links
    foreach ($doc->find('a') as $a) {
      $href = pq($a)->attr('href');
      $href = _parser_get_full_url($href, $page_url);
      
      $allowed = TRUE;
      if ($job->white_list) {
        $allowed = drupal_match_path($href, $job->white_list) ? TRUE : FALSE;
      }
      if ($allowed && $job->black_list) {
        $allowed = drupal_match_path($href, $job->black_list) ? FALSE : TRUE;
      }
      if ($allowed && $job->only_this_domen) {
        $parsed_href = parse_url($href);
        $allowed = ($parsed_url['host'] == $parsed_href['host']);
      }
      if ($allowed) {
        _parser_url_add($href, $url->depth + 1);
      }
    }
  }

  // Parse cur page or not parse
  $allowed_parse = TRUE;
  if (!$page) {
    $allowed_parse = FALSE;
  }
  if ($allowed_parse && $job->parse_limit && $context['sandbox']['created_entities'] >= $job->parse_limit) {
    $allowed_parse = FALSE;
  }
  if ($allowed_parse && $job->check_code) {
    $allowed_parse = eval($job->check_code);
    if ($allowed_parse && !is_bool($allowed_parse)) {
      $page_key = $allowed_parse;
      if (!$entity_id) {
        $entity_id = parser_get_entity_id_by_page_key($page_key, $job->jid);
      }
    }
  }
  if ($allowed_parse && $entity_id && in_array($entity_id, $context['sandbox']['entity_ids'])) {
    $allowed_parse = FALSE;
  }
  if ($allowed_parse && $job->no_update && $entity_id) {
    $allowed_parse = FALSE;
  }
  
  // Parse page
  if ($allowed_parse) {
    $fields = field_info_fields();
    $instances = field_info_instances($job->entity_type, $job->bundle);
    $entity_properties = entity_get_property_info($job->entity_type);
    
    // Load entity
    if ($entity_id) {
      $entity = current(entity_load($job->entity_type, array($entity_id)));
      $context['results']['updated_entities']++;
    }
    // Create entity object
    if (!$entity_id || !$entity) {
      $entity = entity_create($job->entity_type, array($entity_type_info['entity keys']['bundle'] => $job->bundle));
      
      if ($job->entity_type == 'taxonomy_term') {
        $entity->vid = taxonomy_vocabulary_machine_name_load($job->bundle)->vid;
      }
      
      $context['results']['created_entities']++;
    }
    
    $entity_wrapper = entity_metadata_wrapper($job->entity_type, $entity);
    
    // Populate fields
    foreach ($job->fields_code as $field_name => $php_code) {
      if (!$php_code || (!isset($instances[$field_name]) && !isset($entity_properties['properties'][$field_name]))) {
        continue;
      }
      
      $result = eval($php_code);
      
      // Is field
      if (isset($instances[$field_name])) {
        $function = '_parser_attach_field_' . $fields[$field_name]['type'];
        if (!function_exists($function)) {
          $function = '_parser_attach_field';
        }
        $function(
          $entity,
          $field_name,
          $result,
          $job,
          $fields[$field_name],
          $instances[$field_name],
          $page_url,
          $context['results']
        );
      }
      // Is property
      else {
        $entity_wrapper->{$field_name} = $result;
      }
    }
    
    if ($entity) {
      // Set Path alias
      if ($job->save_url && !isset($entity->path)) {
        $entity->path = array(
          'alias' => trim($parsed_url['path'], '/'),
          'language' => LANGUAGE_NONE,
        );
      }
      
      if ($job->prepare_code) {
        eval($job->prepare_code);
      }
      entity_save($job->entity_type, $entity);
      
      $entity_id = entity_id($job->entity_type, $entity);
      
      _parser_map_save(array(
        'entity_id' => $entity_id,
        'jid' => $job->jid,
        'url' => $page_url,
        'page_key' => $page_key,
      ));
    
      $context['sandbox']['entity_ids'][] = $entity_id;
      $context['sandbox']['created_entities']++;
    }
  }
  
  _parser_url_mark_parsed($page_url);

  $context['sandbox']['max'] = _parser_url_count();
  $context['sandbox']['progress']++;
  $context['message'] = '
    Завершён парсинг страницы <em>' . $page_url . '</em> с глубиной ' . $url->depth . '<br />
    Страниц в очереди: ' . ($context['sandbox']['max'] - $context['sandbox']['progress']) . '<br />
    Создано сущностей: ' . $context['results']['created_entities'] . '<br />
    Обновлено сущностей: ' . $context['results']['updated_entities'] . '<br />
    Скачано страниц: ' . $context['results']['pages_from_http'] . '<br />
    Не удалось скачать страниц: ' . $context['results']['error_pages_from_http'] . '<br />
    Страниц взято из кэша: ' . $context['results']['pages_from_cache'] . '<br />
    Скачано файлов: ' . $context['results']['downloaded_files'] . '<br />
    Файлов взято из кэша: ' . $context['results']['files_from_cache'] . '<br />
    Затраченное время: ' . gmdate('H:i:s', time() - $context['results']['time_start']) . '
  ';

  if ($job->parse_limit && $context['sandbox']['created_entities'] >= $job->parse_limit) {
    $context['finished'] = 1;
  }
  elseif ($context['sandbox']['progress'] <= $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Site is parsed
 */
function parser_finished($success, $results, $operations) {
  drupal_set_message('
    ' . ($success ? 'Парсинг закончен' : 'Парсинг закончился с ошибками') . '.
    Обработано страниц: ' . _parser_url_count(TRUE) . '.
    Не удалось скачать страниц: ' . $results['error_pages_from_http'] . '.
    Создано сущностей: ' . l($results['created_entities'], 'admin/structure/parser_jobs/results/' . $results['jid']) . '.
    Обновлено сущностей: ' . l($results['updated_entities'], 'admin/structure/parser_jobs/results/' . $results['jid']) . '.
    Скачано файлов: ' . $results['downloaded_files'] . '.
    Затрачено времени: ' . gmdate('H:i:s', time() - $results['time_start']) . '.
    ' . l('Посмотреть системный журнал', 'admin/reports/dblog') . '
  ');
}

/**
 * Implements of hook_entity_delete().
 * Delete record from {parser_map} table
 */
function parser_entity_delete($entity, $entity_type) {
  $entity_id = entity_id($entity_type, $entity);
    
  $query = db_select('parser_map', 'pm');
  $query->fields('pm', array('jid'));
  $query->innerJoin('parser_jobs', 'pj', 'pj.jid = pm.jid');
  $query->condition('pj.entity_type', $entity_type);
  $query->condition('pm.entity_id', $entity_id);
  $jid = $query->execute()->fetchField();
    
  db_delete('parser_map')
    ->condition('jid', $jid)
    ->condition('entity_id', $entity_id)
    ->execute();
}

/**
 * Implements of hook_entity_view().
 * Show link to original page. Only for admin.
 */
function parser_entity_view($entity, $entity_type, $view_mode, $langcode) {
  $entity_id = entity_id($entity_type, $entity);
  
  if ($view_mode == 'full' && $GLOBALS['user']->uid == 1 && ($url = _parser_get_url_by_entity_id($entity_id))) {
    $entity->content['parser_url'] = array(
      '#markup' => '<p>Контент спарсен со страницы ' . l($url, 'http://anonym.to/?' . $url, array('attributes' => array('target' => '_blank'))) . '</p>', 
      '#weight' => 100, 
    );
  }
}

/**
 * Check php code
 */
function parser_check_code() {
  $params = array('test_url', 'site_charset', 'charset_fix', 'field_name', 'field_value');
  foreach ($params as $param) {
    if (!isset($_POST[$param]) || $_POST[$param] === '') {
      echo 'bad params';
      return NULL;
    }
  }
  
  $page = _parser_get_page_by_url($_POST['test_url'], $_POST['site_charset']);
  $page_url = $_POST['test_url'];
  $doc = _parser_create_phpquery($page, $_POST['charset_fix']);
  $result = eval($_POST['field_value']);
  
  echo print_r($result, TRUE);
}

/**
 * Result page
 */
function parser_result_page($job) {
  $entity_info = entity_get_info($job->entity_type);
  $label_key = $entity_info['entity keys']['label'];
  
  $query = db_select('parser_map', 'pm');
  $query->fields('pm', array('entity_id', 'url', 'page_key'));
  $query->fields('e', array($label_key));
  $query->innerJoin($entity_info['base table'], 'e', 'e.' . $entity_info['entity keys']['id'] . ' = pm.entity_id');
  $query->condition('jid', $job->jid);
  $result = $query->execute();
  
  $rows = array();
  foreach ($result as $row) {
    $entity = current(entity_load($job->entity_type, array($row->entity_id)));
    $uri = entity_uri($job->entity_type, $entity);
    
    $rows[] = array(
      l($row->url, $row->url),
      l($row->{$label_key}, $uri['path'], $uri['options']),
      $row->page_key,
    );
  }
    
  return theme('table', array(
    'header' => array('URL', $label_key, t('Identifier')),
    'rows' => $rows,
    'empty' => 'Пусто...',
  ));
}

/**
 * Implements of hook_form_FORM_ID_alter()
 */
function parser_form_parser_job_overview_form_alter(&$form, $form_state) {
  $form['table']['#header'][2]['colspan'] = 5;
  
  foreach ($form['table']['#rows'] as &$row) {
    $row[] = l(t('results'), 'admin/structure/parser_jobs/results/' . $row[0]['data']['#name']);
  }
}

/**
 * Implements of hook_library().
 */
function parser_library() {
  $parser_path = drupal_get_path('module', 'parser');
    
  $libraries['codemirror'] = array(
    'title' => 'CodeMirror',
    'website' => 'http://codemirror.net/',
    'version' => '2.13',
    'js' => array(
      $parser_path . '/codemirror2/lib/codemirror.js' => array(),
      $parser_path . '/codemirror2/mode/clike/clike.js' => array(),
      $parser_path . '/codemirror2/mode/php/php.js' => array(),
    ),
    'css' => array(
      $parser_path . '/codemirror2/lib/codemirror.css' => array(),
      $parser_path . '/codemirror2/theme/default.css' => array(),
    ),
  );

  return $libraries;
}

/**
 * Return entity id by URL
 */
function parser_get_entity_id_by_url($url, $jid = NULL) {
  $query = db_select('parser_map', 'pn')
    ->fields('pn', array('entity_id'))
    ->condition('url', $url)
    ->range(0, 1);
    
  if ($jid) {
    $query->condition('jid', $jid);
  }
  
  return $query->execute()->fetchField();
}

/**
 * Return entity id by Page Key
 */
function parser_get_entity_id_by_page_key($page_key, $jid = NULL) {
  $query = db_select('parser_map', 'pn')
    ->fields('pn', array('entity_id'))
    ->condition('page_key', $page_key)
    ->range(0, 1);

  if ($jid) {
    $query->condition('jid', $jid);
  }
  
  return $query->execute()->fetchField();
}

/**
 * Get URL info
 */
function _parser_url_get($url) {
  return db_select('parser_urls', 'pu')
    ->fields('pu')
    ->condition('url', $url)
    ->execute()
    ->fetchObject();
}

/**
 * Get first not parsed URL info
 */
function _parser_url_get_not_parsed() {
  return db_select('parser_urls', 'pu')
    ->fields('pu')
    ->condition('parsed', 0)
    //->orderBy('depth', 'DESC')
    ->range(0, 1)
    ->execute()
    ->fetchObject();
}

/**
 * Adding URL to database
 */
function _parser_url_add($url, $depth = 0) {
  if (!_parser_url_get($url)) {
    db_insert('parser_urls')
      ->fields(array(
        'url' => $url,
        'depth' => $depth,
      ))
      ->execute();
  }
}

/**
 * Mark URL as parsed
 */
function _parser_url_mark_parsed($url) {
  db_update('parser_urls')
    ->fields(array('parsed' => 1))
    ->condition('url', $url)
    ->execute();
}

/**
 * Delete all URLs from database
 */
function _parser_url_delete_all() {
  db_truncate('parser_urls')->execute();
}

/**
 * Get count not parsed URLs
 */
function _parser_url_count($parsed = null) {
  $query = db_select('parser_urls', 'pu');
  if (!is_null($parsed)) {
    $query->condition('pu.parsed', $parsed);
  }
  return $query->countQuery()->execute()->fetchField();
}

/**
 * Return page html by URL
 */
function _parser_get_page_by_url($url, $charset = 'auto', $skip_cache = FALSE, &$results = NULL) {
  $cache_uri = 'public://parser_cache/html/' . md5($url) . '.html';

  if (!file_exists($cache_uri) || $skip_cache) {
    $options = array('headers' => array('User-Agent' => 'Opera/9.80 (Windows NT 6.1; U; ru) Presto/2.8.131 Version/11.10')); 
    $result = drupal_http_request($url, $options);
    if ($result->code == 303 && !empty($result->headers['location'])) {
      $result = drupal_http_request($result->headers['location'], $options);
    }
  
    if (!empty($result->data)) {
      $page = $result->data;
      file_unmanaged_save_data($page, $cache_uri);
      
      if ($results) {
        $results['pages_from_http']++;
      }
    }
    else {
      watchdog('parser', 'Не удалось скачать страницу ' . $url . (isset($result->error) ? '. Ошибка: ' . $result->error : ''), array(), WATCHDOG_ALERT);
      
      if ($results) {
        $results['error_pages_from_http']++;
      }
    }
  }
  else {
    $page = file_get_contents($cache_uri);
    
    if ($results) {
      $results['pages_from_cache']++;
    }
  }
  
  // Convert charset
  if ($charset == 'auto') {
    if (preg_match('#<meta http-equiv="Content-Type" content="text/html; charset=([^"])"+#iU', $page, $matches) && drupal_strtolower($matches[1]) != 'utf-8') {
      $page = iconv($matches[1], 'UTF-8', $page);
      $page = str_ireplace(
        '<meta http-equiv="Content-Type" content="text/html; charset=' . $matches[1] . '"',
        '<meta http-equiv="Content-Type" content="text/html; charset=utf-8"',
        $page
      );
    }
  }
  else if ($charset != 'UTF-8') {
    $page = iconv($charset, 'UTF-8', $page);
  }
      
  return $page;
}

/**
 * Attach field to entity object
 */
function _parser_attach_field(&$entity, $field_name, $field_value, $job, $field_info, $field_instance, $page_url) {
  $entity->{$field_name}[LANGUAGE_NONE] = $field_value;
}

/**
 * Attach field type "text" to entity object
 */
function _parser_attach_field_text(&$entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url) {
  if (!is_array($field_values)) {
    $field_values = array($field_values);
  }
  if (isset($entity->{$field_name})) {
    unset($entity->{$field_name});
  }
  
  $i = 0;
  foreach ($field_values as $field_value) {
    $field_value = trim($field_value);
    if (!empty($field_info['settings']['max_length'])) {
      $field_value = drupal_substr($field_value, 0, $field_info['settings']['max_length']);
    }
    
    $entity->{$field_name}[LANGUAGE_NONE][$i]['value'] = $field_value;
  
    if ($field_instance['settings']['text_processing']) {
      $entity->{$field_name}[LANGUAGE_NONE][$i]['format'] = $job->fields_code[$field_name . '_format'];
    }
    
    $i++;
  }
}

/**
 * Attach field type "text_with_summary" to entity object
 */
function _parser_attach_field_text_with_summary(&$entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url) {
  _parser_attach_field_text($entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url);
}

/**
 * Attach field type "file" to entity object
 */
function _parser_attach_field_file(&$entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url, &$results) {
  if (!$field_values) {
    return FALSE;
  }
  if (!is_array($field_values)) {
    $field_values = array($field_values);
  }

  $files = array();
  $field_settings = $field_instance['settings'];
  $dest_dir = 'public://' . $field_settings['file_directory'];
  file_prepare_directory($dest_dir, FILE_CREATE_DIRECTORY);
  $allowed_file_extensions = explode(' ', $field_settings['file_extensions']);

  foreach ($field_values as $field_value) {
    if (!$field_value) {
      continue;
    }
    
    $file_url = _parser_get_full_url($field_value, $page_url);
    $file_name = drupal_basename($field_value);
    $file_ext = pathinfo($file_name, PATHINFO_EXTENSION);
    if (function_exists('transliteration_clean_filename')) {
      $file_name = transliteration_clean_filename($file_name);
    }
    if (drupal_strlen(pathinfo($file_name, PATHINFO_FILENAME)) > 64) {
      $file_name = drupal_substr($file_name, 0, 64) . '.' . $file_ext;
    }
    
    // If file already attached, then break current iteration
    if (isset($entity->{$field_name}[LANGUAGE_NONE])) {
      $cur_file_already_attached = FALSE;
      foreach ($entity->{$field_name}[LANGUAGE_NONE] as $old_file) {
        if ($old_file['filename'] == $file_name) {
          $files[] = $old_file;
          $cur_file_already_attached = TRUE;
          break;
        }
      }
      if ($cur_file_already_attached) {
        continue;
      }
    }
    
    // Validate by extensions
    if (!in_array($file_ext, $allowed_file_extensions)) {
      watchdog('parser', 'Файл <i>' . check_plain($file_url) . '</i> закачан не будет, так как его тип не в списке допустимых.');
      continue;
    }
    
    $cache_uri = 'public://parser_cache/files/' . md5($file_url) . '.' . $file_ext;
    if (!file_exists($cache_uri)) {
      // Download remote file
      $result = drupal_http_request($file_url);

      if (!empty($result->error)) {
        watchdog('parser', 'Ошибка при закачке файла. <b>Адрес</b>: ' . check_plain($file_url) . ', <b>Ошибка</b>: ' . $result->error . ', <b>Результат</b>: ' . check_plain($result->data));
        continue;
      }
      if (!$result->data) {
        watchdog('parser', 'Ошибка при закачке файла. <b>Адрес</b>: ' . check_plain($file_url) . ', <b>Ошибка</b>: сервер не возвратил данных.');
        continue;
      }
    
      // Save file to cache
      file_unmanaged_save_data($result->data, $cache_uri);
      $results['downloaded_files']++;
    }
    else {
      $results['files_from_cache']++;
    }
    
    // Copy file from cache to $dest_dir
    $file = (object)array(
      'uid' => $GLOBALS['user']->uid,
      'uri' => $cache_uri,
      'filename' => $file_name,
      'filemime' => file_get_mimetype($cache_uri),
    );
    $file_path = file_stream_wrapper_uri_normalize($dest_dir . '/' . $file_name);
    $file = file_copy($file, $file_path);
    if ($file) {
      $files[] = (array)$file + array('display' => 1);
    }
  }
  
  if (isset($entity->{$field_name})) {
    unset($entity->{$field_name});
  }
  
  $entity->{$field_name}[LANGUAGE_NONE] = $files;
}

/**
 * Attach field type "image" to entity object
 */
function _parser_attach_field_image(&$entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url, &$results) {
  _parser_attach_field_file($entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url, $results);
}

/**
 * Attach field type "taxonomy_term_reference" to entity object
 */
function _parser_attach_field_taxonomy_term_reference(&$entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url) {
  if (!is_array($field_values)) {
    $field_values = array($field_values);
  }
  if (isset($entity->{$field_name})) {
    unset($entity->{$field_name});
  }
  
  $voc_machine_name = $field_info['settings']['allowed_values'][0]['vocabulary'];
  $voc = taxonomy_vocabulary_machine_name_load($voc_machine_name);

  foreach ($field_values as $term_name) {
    $term_name = trim($term_name);
    $term = current(taxonomy_term_load_multiple(array(), array('name' => $term_name, 'vid' => $voc->vid)));
    if (!$term) {
      $term = (object)array('vid' => $voc->vid, 'name' => $term_name);
      taxonomy_term_save($term);
    }
    $entity->{$field_name}[LANGUAGE_NONE][]['tid'] = $term->tid;
  }
}

/**
 * Attach field type "number_integer" to entity object
 */
function _parser_attach_field_number_integer(&$entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url) {
  if (!is_array($field_values)) {
    $field_values = array($field_values);
  }
  if (isset($entity->{$field_name})) {
    unset($entity->{$field_name});
  }
  foreach ($field_values as $field_value) {
    $entity->{$field_name}[LANGUAGE_NONE][]['value'] = (int)$field_value;
  }
}

/**
 * Attach field type "list_text" to entity object
 */
function _parser_attach_field_list_text(&$entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url) {
  if (!is_array($field_values)) {
    $field_values = array($field_values);
  }
  if (isset($entity->{$field_name})) {
    unset($entity->{$field_name});
  }

  $allowed_values = $field_info['settings']['allowed_values'];
  foreach ($field_values as $field_value) {
    $field_value = trim($field_value);
    
    if (!isset($allowed_values[$field_value])) {
      $key = array_search($field_value, $allowed_values, TRUE);
      if ($key !== FALSE) {
        $field_value = $key;
      }
      else {
        continue;
      }
    }
  
    $entity->{$field_name}[LANGUAGE_NONE][]['value'] = $field_value;
  }
}

/**
 * Attach field type "node_reference" to entity object
 */
function _parser_attach_field_node_reference(&$entity, $field_name, $field_values, $job, $field_info, $field_instance, $page_url) {
  if (!is_array($field_values)) {
    $field_values = array($field_values);
  }
  if (isset($entity->{$field_name})) {
    unset($entity->{$field_name});
  }

  foreach ($field_values as $field_value) {
    $entity->{$field_name}[LANGUAGE_NONE][]['nid'] = (int)$field_value;
  }
}

/**
 * Add row in {parser_map} table
 */
function _parser_map_save($record) {
  db_merge('parser_map')
    ->key(array('entity_id' => $record['entity_id']))
    ->fields(array(
      'jid' => $record['jid'],
      'url' => $record['url'],
      'page_key' => $record['page_key'],
    ))
    ->execute();
}

/**
 * Return URL by entity id
 */
function _parser_get_url_by_entity_id($entity_id, $jid = NULL) {
  $query = db_select('parser_map', 'pn')
    ->fields('pn', array('url'))
    ->condition('entity_id', $entity_id);
    
  if ($jid) {
    $query->condition('jid', $jid);
  }
  
  return $query->execute()->fetchField();
}

/**
 * Return row count
 */
function _parser_get_rows($text) {
  $count = substr_count(trim($text), "\n") + 1;
  return $count > 3 ? $count : 3;
}

/**
 * Set row count
 */
function _parser_set_rows(&$form) {
  foreach (element_children($form) as $element) {
    if (isset($form[$element]['#type']) && $form[$element]['#type'] == 'textarea') {
      $form[$element]['#rows'] = _parser_get_rows($form[$element]['#default_value']);
    }
    else {
      _parser_set_rows($form[$element]);
    }
  }
}

/**
 * Return full url
 */
function _parser_get_full_url($url, $page_url) {
  $url = trim($url);
  $url = preg_replace('/#.+/', '', $url);
  $page_url_parsed = parse_url($page_url);

  if (substr($url, 0, 1) == '/') {
    $url = $page_url_parsed['scheme'] . '://' . $page_url_parsed['host'] . $url;
  }
  elseif (strpos($url, 'http') !== 0) {
    $page_url = rtrim($page_url, '/');
    $page_url = preg_replace('#/[^/]+$#', '', $page_url);
    $url = $page_url . '/' . $url;
  }
  
  $url = str_replace(' ', '+', $url);
  $url = current(explode('#', $url));
  
  return $url;
}

/**
 * Download file to local storage
 */
function _parser_download_file_use_curl($file_url, $destination) {
  $ch = curl_init($file_url);
  $fp = fopen(drupal_realpath($destination), 'wb');
  curl_setopt($ch, CURLOPT_FILE, $fp);
  curl_setopt($ch, CURLOPT_HEADER, 0);
  curl_exec($ch);
  $error = curl_error($ch);
  curl_close($ch);
  fclose($fp);
  
  return $error;
}

/**
 * Clear vocabulary
 */
function _parser_clear_vocabulary($vocabulary_name) {
  $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_name);
  $terms = taxonomy_get_tree($vocabulary->vid);

  foreach ($terms as $term) {
    taxonomy_term_delete($term->tid);
  }
}

/**
 * Create phpQuery object
 */
function _parser_create_phpquery($html, $charset_fix = FALSE) {
  require_once('phpQuery/phpQuery/phpQuery.php');
  return phpQuery::newDocumentHTML($html, $charset_fix ? 'utf8' : NULL);
}

/**
 * Return TRUE if $name is entity field
 */
function _parser_is_entity_field($name, $instance) {
  /*if ($entity_properties[]) {
    
  }*/
}
